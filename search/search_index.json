{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WTHIT Documentation Welcome to WTHIT documentation!","title":"WTHIT Documentation"},{"location":"#wthit-documentation","text":"Welcome to WTHIT documentation!","title":"WTHIT Documentation"},{"location":"config/blacklisting/","text":"Blacklisting Blocks and Entities To blacklist some blocks from WTHIT, create a block tag called waila:blacklist . See an entry about datapack tags on Minecraft Wiki here . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Blacklisting Blocks and Entities"},{"location":"config/blacklisting/#blacklisting-blocks-and-entities","text":"To blacklist some blocks from WTHIT, create a block tag called waila:blacklist . See an entry about datapack tags on Minecraft Wiki here . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Blacklisting Blocks and Entities"},{"location":"plugin/adding_to_blacklist/","text":"Adding to Blacklist Unlike overriding object to disable the tooltip, adding it to the blacklist means the player can override those values. You can add blocks, block entity types, and entity types to the blacklist. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addBlacklist ( Blocks . OAK_PLANKS , Blocks . CRAFTING_TABLE ); registrar . addBlacklist ( EntityType . MINECART ); } } Using tag to add to blacklist This method only viable if your mod also adds new blocks and/or entities since this would require the tag to be present on the server. Create a tag called waila:blacklist . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Adding to Blacklist"},{"location":"plugin/adding_to_blacklist/#adding-to-blacklist","text":"Unlike overriding object to disable the tooltip, adding it to the blacklist means the player can override those values. You can add blocks, block entity types, and entity types to the blacklist. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addBlacklist ( Blocks . OAK_PLANKS , Blocks . CRAFTING_TABLE ); registrar . addBlacklist ( EntityType . MINECART ); } }","title":"Adding to Blacklist"},{"location":"plugin/adding_to_blacklist/#using-tag-to-add-to-blacklist","text":"This method only viable if your mod also adds new blocks and/or entities since this would require the tag to be present on the server. Create a tag called waila:blacklist . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Using tag to add to blacklist"},{"location":"plugin/config/","text":"Plugin Configuration Not everyone wanted every feature from your plugin, so making them configurable is recommended. IRegistrar has multiple methods for registering a config option: addConfig This method registers a local-only option. This is recommended for cosmetic-only options. addSyncedConfig This method registers a server option. The server will force connected clients to have the same value. If the client is connected to a server that doesn't have WTHIT, its value will be locked to the specified client-only value. addMergedConfig Like addSyncedConfig , the server will send its option value to connected clients but it won't force the value. When the server enabled the option, the client can freely disable it for their side. Recommended for toggle for a feature that works client-only. addMergedSyncedConfig This is pretty much the same as addMergedConfig but with the additional rule that the server needs to have WTHIT installed, otherwise, the option will be locked to a predetermined value. Recommended for toggle for a feature that needs server-synced data to work properly.","title":"Plugin Configuration"},{"location":"plugin/config/#plugin-configuration","text":"Not everyone wanted every feature from your plugin, so making them configurable is recommended. IRegistrar has multiple methods for registering a config option:","title":"Plugin Configuration"},{"location":"plugin/config/#addconfig","text":"This method registers a local-only option. This is recommended for cosmetic-only options.","title":"addConfig"},{"location":"plugin/config/#addsyncedconfig","text":"This method registers a server option. The server will force connected clients to have the same value. If the client is connected to a server that doesn't have WTHIT, its value will be locked to the specified client-only value.","title":"addSyncedConfig"},{"location":"plugin/config/#addmergedconfig","text":"Like addSyncedConfig , the server will send its option value to connected clients but it won't force the value. When the server enabled the option, the client can freely disable it for their side. Recommended for toggle for a feature that works client-only.","title":"addMergedConfig"},{"location":"plugin/config/#addmergedsyncedconfig","text":"This is pretty much the same as addMergedConfig but with the additional rule that the server needs to have WTHIT installed, otherwise, the option will be locked to a predetermined value. Recommended for toggle for a feature that needs server-synced data to work properly.","title":"addMergedSyncedConfig"},{"location":"plugin/disabling_tooltip/","text":"Disabling Tooltip Disabling Tooltip for Certain Objects Sometimes you want to disable the tooltip for showing altogether. To do that, WTHIT contains a static variable on I*ComponentProvider that we can use as a return value for getOverride . public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return EMPTY_BLOCK_STATE ; } } public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EMPTY_ENTITY ; } }","title":"Disabling Tooltip"},{"location":"plugin/disabling_tooltip/#disabling-tooltip","text":"","title":"Disabling Tooltip"},{"location":"plugin/disabling_tooltip/#disabling-tooltip-for-certain-objects","text":"Sometimes you want to disable the tooltip for showing altogether. To do that, WTHIT contains a static variable on I*ComponentProvider that we can use as a return value for getOverride . public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return EMPTY_BLOCK_STATE ; } } public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EMPTY_ENTITY ; } }","title":"Disabling Tooltip for Certain Objects"},{"location":"plugin/getting_started/","text":"Getting Started Gradle Setup To get started making a WTHIT plugin, add the following to your build.gradle Adding Repository repositories { maven { url \"https://maven.bai.lol\" } } Declaring Dependencies Fabric Forge Quilt Architectury VanillaGradle Multiplatform dependencies { // compile against the API modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\" // run against the full jar modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } buildscript { dependencies { classpath \"org.spongepowered:mixingradle:0.7.+\" } } apply plugin: \"org.spongepowered.mixin\" dependencies { // compile against the API compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\") // run against the full jar runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\") runtimeOnly fg.deobf(\"lol.bai:badpackets:forge-0.2.0\") } dependencies { // compile against the API modCompileOnly \"mcp.mobius.waila:wthit-api:quilt-${wthitVersion}\" // run against the full jar modRuntimeOnly \"mcp.mobius.waila:wthit:quilt-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Common Project dependencies { modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\" } Fabric Project dependencies { modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Forge Project dependencies { // needed for @WailaPlugin annotation modCompileOnly \"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\" modRuntimeOnly \"mcp.mobius.waila:wthit:forge-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:forge-0.2.0\" } Common Project dependencies { compileOnly \"mcp.mobius.waila:wthit-api:mojmap-${wthitVersion}\" } Fabric Project dependencies { modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Forge Project buildscript { dependencies { classpath \"org.spongepowered:mixingradle:0.7.+\" } } apply plugin: \"org.spongepowered.mixin\" dependencies { // needed for @WailaPlugin annotation compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\") runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\") runtimeOnly fg.deobf(\"lol.bai:badpackets:forge-0.2.0\") } Quilt Project dependencies { modRuntimeOnly \"mcp.mobius.waila:wthit:quilt-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Why compiling against the API jar? When you compile against the full jar and use non API classes, your mod could break any time WTHIT updates. On the other hand, the API jar is guaranteed to be stable. No breaking changes without deprecation time. If you found yourself needing to touch non API classes, open an issue on GitHub . Available packages All packages has mcp.mobius.waila as their group. Package Description wthit-api:fabric-${version} Intermediary API jar for Loom projects wthit-api:forge-${version} SRG API jar for ForgeGradle projects wthit-api:quilt-${version} Currently intermediary API jar, would be hashed-mojmap when Quilt supports building it wthit-api:mojmap-${version} Mojang Mappings API jar for VanillaGradle projects wthit:fabric-${version} Full runtime jar for Fabric wthit:forge-${version} Full runtime jar for Forge wthit:quilt-${version} Full runtime jar for Quilt wthit:mojmap-${version} Full platform independent jar for strange people that need access to internal implementations Creating Plugins Making a Plugin Class Make a class that implements IWailaPlugin public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { // register your component here } } Registering Plugins Create a file called waila_plugins.json in the root of your mod, commonly in src/main/resources folder on your project. { // the plugin identifier, [namespace:path] \"yourmodid:plugin\" : { // the path to the implementation class \"initializer\" : \"package.YourWailaPlugin\" , // optional, decide the environment the plugin will loaded, options: // client load plugin only on client and integrated server // server load plugin only on dedicated server // * load plugin on both client and dedicated server \"side\" : \"*\" , // optional, the required mods that this plugin needs \"required\" : [ \"othermodid\" , \"anotherone\" ] }, // register multiple plugins! \"yourmodid:another\" : { /*...*/ } }","title":"Getting Started"},{"location":"plugin/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"plugin/getting_started/#gradle-setup","text":"To get started making a WTHIT plugin, add the following to your build.gradle","title":"Gradle Setup"},{"location":"plugin/getting_started/#adding-repository","text":"repositories { maven { url \"https://maven.bai.lol\" } }","title":"Adding Repository"},{"location":"plugin/getting_started/#declaring-dependencies","text":"Fabric Forge Quilt Architectury VanillaGradle Multiplatform dependencies { // compile against the API modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\" // run against the full jar modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } buildscript { dependencies { classpath \"org.spongepowered:mixingradle:0.7.+\" } } apply plugin: \"org.spongepowered.mixin\" dependencies { // compile against the API compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\") // run against the full jar runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\") runtimeOnly fg.deobf(\"lol.bai:badpackets:forge-0.2.0\") } dependencies { // compile against the API modCompileOnly \"mcp.mobius.waila:wthit-api:quilt-${wthitVersion}\" // run against the full jar modRuntimeOnly \"mcp.mobius.waila:wthit:quilt-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Common Project dependencies { modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\" } Fabric Project dependencies { modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Forge Project dependencies { // needed for @WailaPlugin annotation modCompileOnly \"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\" modRuntimeOnly \"mcp.mobius.waila:wthit:forge-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:forge-0.2.0\" } Common Project dependencies { compileOnly \"mcp.mobius.waila:wthit-api:mojmap-${wthitVersion}\" } Fabric Project dependencies { modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Forge Project buildscript { dependencies { classpath \"org.spongepowered:mixingradle:0.7.+\" } } apply plugin: \"org.spongepowered.mixin\" dependencies { // needed for @WailaPlugin annotation compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\") runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\") runtimeOnly fg.deobf(\"lol.bai:badpackets:forge-0.2.0\") } Quilt Project dependencies { modRuntimeOnly \"mcp.mobius.waila:wthit:quilt-${wthitVersion}\" modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\" } Why compiling against the API jar? When you compile against the full jar and use non API classes, your mod could break any time WTHIT updates. On the other hand, the API jar is guaranteed to be stable. No breaking changes without deprecation time. If you found yourself needing to touch non API classes, open an issue on GitHub . Available packages All packages has mcp.mobius.waila as their group. Package Description wthit-api:fabric-${version} Intermediary API jar for Loom projects wthit-api:forge-${version} SRG API jar for ForgeGradle projects wthit-api:quilt-${version} Currently intermediary API jar, would be hashed-mojmap when Quilt supports building it wthit-api:mojmap-${version} Mojang Mappings API jar for VanillaGradle projects wthit:fabric-${version} Full runtime jar for Fabric wthit:forge-${version} Full runtime jar for Forge wthit:quilt-${version} Full runtime jar for Quilt wthit:mojmap-${version} Full platform independent jar for strange people that need access to internal implementations","title":"Declaring Dependencies"},{"location":"plugin/getting_started/#creating-plugins","text":"","title":"Creating Plugins"},{"location":"plugin/getting_started/#making-a-plugin-class","text":"Make a class that implements IWailaPlugin public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { // register your component here } }","title":"Making a Plugin Class"},{"location":"plugin/getting_started/#registering-plugins","text":"Create a file called waila_plugins.json in the root of your mod, commonly in src/main/resources folder on your project. { // the plugin identifier, [namespace:path] \"yourmodid:plugin\" : { // the path to the implementation class \"initializer\" : \"package.YourWailaPlugin\" , // optional, decide the environment the plugin will loaded, options: // client load plugin only on client and integrated server // server load plugin only on dedicated server // * load plugin on both client and dedicated server \"side\" : \"*\" , // optional, the required mods that this plugin needs \"required\" : [ \"othermodid\" , \"anotherone\" ] }, // register multiple plugins! \"yourmodid:another\" : { /*...*/ } }","title":"Registering Plugins"},{"location":"plugin/overrides/","text":"Overrides If you have special blocks that shows itself as another block (example: facades), you would want that block to show the imitated block on WTHIT as well. To do that, you need to register a block override provider. Block Override In this example we wanted to show powder snow block as regular snow block. First create a class that implements IBlockComponentProvider and override the getOverride method. In there you return the block state that you want to immitate into. Yarn Mojang public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . getDefaultState (); } } public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . defaultBlockState (); } } Then you register the class on your main plugin class. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new BlockOverride (), PowderSnowBlock . class ); } } Priority WTHIT will choose the first override with lower priority number. a <= b ? a : b Entity Override It's also applicable for entities, simply make a class implementing IEntityComponentProvider public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EntityType . SHEEP . create ( accessor . getWorld ()); } } public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new EntityOverride (), PigEntity . class ); } } Caching Unlike BlockState , an Entity instance is not cached on any way. This can possibly cause performance issue if you have a many overrides. To mimimalize this, you need to cache it yourself. Since *ComponentProvider is a client-only class, caching based on world and/or position should be enough for most cases.","title":"Overrides"},{"location":"plugin/overrides/#overrides","text":"If you have special blocks that shows itself as another block (example: facades), you would want that block to show the imitated block on WTHIT as well. To do that, you need to register a block override provider.","title":"Overrides"},{"location":"plugin/overrides/#block-override","text":"In this example we wanted to show powder snow block as regular snow block. First create a class that implements IBlockComponentProvider and override the getOverride method. In there you return the block state that you want to immitate into. Yarn Mojang public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . getDefaultState (); } } public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . defaultBlockState (); } } Then you register the class on your main plugin class. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new BlockOverride (), PowderSnowBlock . class ); } } Priority WTHIT will choose the first override with lower priority number. a <= b ? a : b","title":"Block Override"},{"location":"plugin/overrides/#entity-override","text":"It's also applicable for entities, simply make a class implementing IEntityComponentProvider public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EntityType . SHEEP . create ( accessor . getWorld ()); } } public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new EntityOverride (), PigEntity . class ); } } Caching Unlike BlockState , an Entity instance is not cached on any way. This can possibly cause performance issue if you have a many overrides. To mimimalize this, you need to cache it yourself. Since *ComponentProvider is a client-only class, caching based on world and/or position should be enough for most cases.","title":"Entity Override"}]}